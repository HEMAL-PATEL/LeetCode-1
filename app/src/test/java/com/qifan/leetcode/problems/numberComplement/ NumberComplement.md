给定一个正整数，输出它的补数。补数是对该数的二进制表示取反。

注意:

    给定的整数保证在32位带符号整数的范围内。
    你可以假定二进制数不包含前导零位。

```
示例 1:

输入: 5
输出: 2
解释: 5的二进制表示为101（没有前导零位），其补数为010。所以你需要输出2。

示例 2:

输入: 1
输出: 0
解释: 1的二进制表示为1（没有前导零位），其补数为0。所以你需要输出0。

```


`Integer.highestOneBit(i)` 是一个什么样的函数呢？

 - 1、在计算机系统中，数值一律使用补码来表示和存储。主要原因是使用补码可以将符号位和其它位统一处理；同时，减法也可按照加法来处理。另 外，   两个用补码表示的数相加时，如果最高位（符号位）有进位，则进位被舍弃。
    - 补码与原码的转换过程几乎相同。
        - 数值的补码表示（分两种）
            - 正数的补码：与原码相同
            - 负数的补码：符号位位1，其余位位该数绝对值的原码按位取反；然后整个数加1
        - 已知一个数的补码，求原码的操作分为两种情况
            - 如果补码的符号位“0”，表示是一个正数，所以补码就是该数的原码
            - 如果补码的符号位为“1”，表示是一个负数，求原码的操作可以是：符号位位1，其余各位取反，然后整个数加1。
- 2、移位运算符就是在二进制的基础上对数字进行平移。Java按照平移的方向和填充数字的规则分为三种：<<左移，>>带符号右移 和>>>无符号右移。
- 3、 在Java的移位运算中，byte、short和char类型移位后的结果会变成int类型，对于byte、short、char和int进行移位时，对于char、short、char和int进行移位操作时，规定实际移动的次数是移动次数和32的余数，也就是移位33次和移位1次得到的结果相同。移动long型的数值时，规定实际移动的次数是移动次数和64的余数，也就是移动65次移位1次得到相同的结果。
    - （1） <<  运算规则：按二进制形式吧所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。
    语法格式：
         需要移位的数字<<移位的次数
         例如：4<<2 ，则是将数字4左移2位
     计算过程
         4<<2
        Java中一个int数占四个字节，那么4的二进制数字为00000000 00000000 00000000 00000100，然后把该数字左移两位。其它的数字都朝右平移两位，最后在低位（右侧）的两个空位补零。则得到的最终结果是00000000 00000000 00000000 00010000，即转换为十进制数16。
         在数字没有溢出的前提下，对于正数和负数，左移一位都相当于乘以2的1次方，左移n位就相当于乘以2的n次方。
         在溢出的前提前，则不符合这个规律。读者可以尝试输出(long)1610612736*4和1610612736<<2这两个结果进行比对。
    - （2）>>运算规则：按二进制形式吧所有的数字都向右移动对应的位置，低位移出（舍弃），高位的空位补符号位，即正数补零，负数补1。
     语法格式：
         需要移位的数字>>移位的次数
         例如：-4>>2和4>>2，则是将数字 -4和4右移2位
     计算过程
         4>>2
         Java中一个int数占四个字节，同样4的二进制为00000000 00000000 00000000 00000100，然后把该数字右移两位。其它的数字都朝左平移两位，最后在高位补符号位（该数是正数，全补零），得到的结果是00000000 00000000 00000000 00000001，即使十进制的1。数学意义就是右移移位相当于除2，右移n位相当于除以2的n次方。
        4>>2
         由于负数在计算机中是以补码的形式存储的，那么-4的二进制为11111111 11111111 11111111 11111100,然后把该数字右移两位，其它数字都朝左平移两位，最后在高位补符号位（该数是负数，全补一），得到的结果是11111111 11111111 11111111 11111111（补码格式），即是十进制的-1。
    - （3）>>>运算规则：按二进制形式吧所有的数字向右移动对应的位数，低位移出（舍弃），高位的空位补零。正数运算结果与带符号右移相同，对于负数来说则不同。
         对于4>>>2和-4>>>2运算，可以通过上述例子进行类推。
 
了解了Java的位运算之后，来看下  Integer.highestOneBit (i) 这个函数的实现代码：
 
 ```java
 public static int highestOneBit(int i) {  
      // HD, Figure 3-1  
      i |= (i >>  1);  
      i |= (i >>  2);  
      i |= (i >>  4);  
      i |= (i >>  8);  
      i |= (i >> 16);  
      return i - (i >>> 1);  
  }  
 ```

 